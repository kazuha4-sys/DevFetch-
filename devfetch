#!/usr/bin/env bash
# ================================
# Devfetch - Uma ferramenta para ajudar Dev's na organiza√ß√£o de projetos
# Mostra infos √∫teis para o Dev
# ================================

VERSION="1.2.0"
REPO_URL="https://github.com/kazuha4-sys/devfetch.git"
SCRIPT_PATH=$(realpath "$0")
CONFIG_DIR="$HOME/.config/devfetch"
CONFIG_FILE="$CONFIG_DIR/config"


# Criar config se n√£o existir 
mkdir -p "$CONFIG_DIR"

[ ! -f "$CONFIG_FILE" ] && echo "auto_update=false" > "$CONFIG_FILE"

get_config() {
    grep "$1" "$CONFIG_FILE" | cut -d'=' -f2
}


set_config() {
    key="$1"
    value="$2"
    if grep -q "$key" "$CONFIG_FILE"; then
        sed -i "s/^$key=.*/$key=$value/" "$CONFIG_FILE"
    else
        echo "$key=$value" >> "$CONFIG_FILE"
    fi
}

check_update() {
    latest_version=$(curl -s "https://raw.githubusercontent.com/kazuha4-sys/devfetch/main/VERSION" 2>/dev/null)
    if [ -z "$latest_version" ]; then
        echo "\e[31m[ X ]\e[0m  N√£o foi poss√≠vel verificar atualiza√ß√µes."
        return
    fi

    if [ "$latest_version" != "$VERSION" ]; then
        echo " Nova vers√£o dispon√≠vel: $latest_version (atual: $VERSION)"
        return 0
    else
        echo " Devfetch j√° est√° atualizado!"
        return 1
    fi
}

update_devfetch() {
    check_update || return
    echo -n "Deseja atualizar agora? (s/n): "
    read -r ans
    if [ "$ans" = "s" ]; then
        echo "Baixando nova vers√£o..."
        tmpfile=$(mktemp)
        curl -sL "https://raw.githubusercontent.com/kazuha4-sys/devfetch/main/devfetch" -o "$tmpfile"
        chmod +x "$tmpfile"
        mv "$tmpfile" "$SCRIPT_PATH"
        echo " Atualizado com sucesso para a vers√£o mais nova!"
    else
        echo " Atualiza√ß√£o cancelada."
    fi
}

auto_update_check() {
    auto=$(get_config "auto_update")
    if [ "$auto" = "true" ]; then
        check_update && update_devfetch
    fi
}

# ================================
# ASCII Art
# ================================
ascii=$(cat << 'ASCII'
\e[34m    ____                  ______         __            __ \e[0m
\e[34m   / __ \  ___  _   __   / ____/  ___   / /_  _____   / /_ \e[0m
\e[34m  / / / / / _ \| | / /  / /_     / _ \ / __/ / ___/  / __ \ \e[0m
\e[34m / /_/ / /  __/| |/ /  / __/    /  __// /_  / /__   / / / / \e[0m
\e[34m/_____/  \___/ |___/  /_/       \___/ \__/  \___/  /_/ /_/ \e[0m
____________________________________________________________                                                        
ASCII
)


ascii_laravel=$(cat << 'ASCII'
\e[31m    ‚ñà‚ñà‚ñà‚ñà‚ñà \e[0m                      
\e[31m ‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà \e[0m                   
\e[31m‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà         ‚ñà‚ñà ‚ñà‚ñà \e[0m   
\e[31m‚ñà   ‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà     ‚ñà‚ñà‚ñà       ‚ñà‚ñà‚ñà \e[0m
\e[31m‚ñà     ‚ñà     ‚ñà     ‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà‚ñà \e[0m
\e[31m‚ñà     ‚ñà     ‚ñà     ‚ñà    ‚ñà‚ñà‚ñà    ‚ñà \e[0m
\e[31m‚ñà     ‚ñà     ‚ñà     ‚ñà     ‚ñà     ‚ñà \e[0m
\e[31m‚ñà     ‚ñà     ‚ñà    ‚ñà‚ñà‚ñà    ‚ñà    ‚ñà‚ñà \e[0m
\e[31m‚ñà     ‚ñà     ‚ñà ‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \e[0m  
\e[31m‚ñà     ‚ñà   ‚ñà‚ñà‚ñà         ‚ñà‚ñà‚ñà \e[0m     
\e[31m‚ñà     ‚ñà‚ñà‚ñà‚ñà         ‚ñà‚ñà‚ñà  ‚ñà \e[0m     
\e[31m‚ñà      ‚ñà‚ñà       ‚ñà‚ñà      ‚ñà \e[0m    
\e[31m‚ñà         ‚ñà‚ñà‚ñà‚ñà‚ñà         ‚ñà \e[0m     
\e[31m ‚ñà‚ñà‚ñà        ‚ñà        ‚ñà‚ñà‚ñà \e[0m      
\e[31m     ‚ñà‚ñà     ‚ñà     ‚ñà‚ñà \e[0m          
\e[31m        ‚ñà‚ñà‚ñà ‚ñà ‚ñà‚ñà‚ñà \e[0m             
\e[31m           ‚ñà‚ñà‚ñà \e[0m                

ASCII
)

ascii_git=$(cat << 'ASCII'
\e[33m        _  _   \e[0m
\e[31m       (_)| |  \e[0m
\e[32m  __ _  _ | |_ \e[0m
\e[34m / _\` || || __|\e[0m
\e[33m| (_| || || |_ \e[0m
\e[31m \__, ||_| \__|\e[0m
\e[32m  __/ | _______       \e[0m
\e[34m |___/ / \e[0m
\e[33m _____/ \e[0m

ASCII
)
   
# ================================
# Fun√ß√µes principais
# ================================

menu() {
    while true; do
        clear

        # joga o ascii em linhas
        ascii_lines=()
        while IFS= read -r line; do
            ascii_lines+=("$line")
        done < <(printf "%b\n" "$ascii")
        # printa o ascii
        for line in "${ascii_lines[@]}"; do
            echo -e "$line"
        done
        echo "  (1) Git"
        echo "  (2) Docker"
        echo "  (3) Dev"
        echo "  (4) Laravel"
        echo "  (0) Sair"
        echo
        read -p "Escolhe uma op√ß√£o: " opt

        case "$opt" in
            1) devfetch --loop_git ;;
            2) devfetch --docker ;;
            3) devfetch --dev ;;
            4) devfetch --loop_laravel ;;
            0) echo "Saindo do DevFetch..."; break ;;
            *) echo -e "\e[31m[ X ]\e[0m Digite um dos numeros das op√ß√µes" ;;
        esac

        echo
        read -p "" temp
    done
}

show_dev() {
    # joga o ascii em linhas
    ascii_lines=()
    while IFS= read -r line; do
        ascii_lines+=("$line")
    done < <(printf "%b\n" "$ascii")

    # aqui tu imprime o ascii
    for line in "${ascii_lines[@]}"; do
        echo "$line"
    done
    echo "____________________________________________________________"
    echo

    # agora mostra infos de vers√µes
    echo "PHP Version: $(php -v 2>/dev/null | head -n1 | awk '{print $2}' || echo 'n√£o encontrado')"
    echo "Node Version: $(node -v 2>/dev/null | sed 's/v//' || echo 'n√£o encontrado')"
    echo "Python Version: $(python3 --version 2>/dev/null | awk '{print $2}' || echo 'n√£o encontrado')"
    echo "Laravel Version: $(php artisan --version 2>/dev/null)"
    echo "Composer Version: $(composer --version 2>/dev/null | awk '{print $3}' || echo 'n√£o encontrado')"


    if command -v systemctl &>/dev/null; then
        echo "MySQL: $(systemctl is-active mysql 2>/dev/null || echo 'desconhecido')"
        echo "Redis: $(systemctl is-active redis 2>/dev/null || echo 'desconhecido')"
    else
        echo "MySQL: $(command -v mysql &>/dev/null && echo 'instalado' || echo 'n√£o encontrado')"
        echo "Redis: $(command -v redis-server &>/dev/null && echo 'instalado' || echo 'n√£o encontrado')"
    fi
}
show_laravel() {
    # joga o ascii em linhas
    ascii_lines=()
    while IFS= read -r line; do
        ascii_lines+=("$line")
    done < <(printf "%b\n" "$ascii_laravel")

    # printa o ascii
    for line in "${ascii_lines[@]}"; do
        echo -e "$line"
    done
    echo

    # checa se √© projeto laravel
    if [ ! -f "artisan" ]; then
        echo -e "\e[31m[Laravel]\e[0m N√£o achei o arquivo \`artisan\` aqui. Vai pra pasta do projeto antes, mano."
        return
    fi

    # vers√£o
    version=$(php artisan --version 2>/dev/null)
    echo -e "\e[32m[Laravel]\e[0m $version"
    echo "____________________________________________________________"

    # fun√ß√£o interna pra ler .env (se existir)
    read_env() {
        local key="$1"
        if [ -f ".env" ]; then
            # pega a √∫ltima ocorr√™ncia da chave, remove o prefixo KEY= e tira aspas ao redor
            awk -F= -v k="$key" '
                $1 == k { $1=""; sub(/^=/,""); val=$0 }
                END {
                    if (val=="") { print ""; exit }
                    # remove aspas simples ou duplas ao redor
                    if (val ~ /^".*"$/ || val ~ /^'\''.*'\''$/) {
                        gsub(/^["'\'']|["'\'']$/,"",val)
                    }
                    # trim
                    sub(/^[ \t]+/,"",val); sub(/[ \t]+$/,"",val);
                    print val
                }' .env 2>/dev/null || echo ""
        else
            echo ""
        fi
    }


    APP_NAME=$(read_env "APP_NAME")
    APP_ENV=$(read_env "APP_ENV")
    APP_DEBUG=$(read_env "APP_DEBUG")
    APP_KEY=$(read_env "APP_KEY")

    echo "App Name: ${APP_NAME:-n√£o configurado}"
    echo "App Env:  ${APP_ENV:-desconhecido}"
    echo "Debug:    ${APP_DEBUG:-desconhecido}"
    if [ -n "$APP_KEY" ]; then
        echo "Key:      ${APP_KEY:0:20}... (oculta)"
    else
        echo "Key:      n√£o definida"
    fi

    # mostra um menu interativo
    while true; do
        echo
        echo -e "\e[36mEscolha uma op√ß√£o Laravel (digita o n√∫mero e d√° enter):\e[0m"
        echo " 1) Rodar migrations (php artisan migrate)"
        echo " 2) Ver status das migrations (php artisan migrate:status)"
        echo " 3) Listar rotas (route:list)"
        echo " 4) Limpar cache/config/routes (cache:clear, config:clear, route:clear)"
        echo " 5) Mostrar Database (tenta usar .env e cliente mysql/sqlite)"
        echo " 6) Ver filas (queue:failed e queue:work status)"
        echo " 7) Criar storage link (php artisan storage:link)"
        echo " 8) Voltar / Sair"
        read -p "Op√ß√£o: " lar_opt

        case "$lar_opt" in
            1)
                # confirma por seguran√ßa
                read -p "Certeza que quer rodar migrations (ir√° alterar DB)? (s/N): " yn
                case "$yn" in
                    [sS]|[yY])
                        echo "Rodando migrations... segura a√≠."
                        php artisan migrate --force || echo "Falha ao rodar migrate. Checa as configs."
                        ;;
                    *)
                        echo "Beleza, n√£o rodei nada."
                        ;;
                esac
                ;;

            2)
                echo "Status das migrations:"
                php artisan migrate:status || echo "N√£o consegui pegar o status."
                ;;

            3)
                echo "Rotas (mostrando primeiras 200 linhas):"
                php artisan route:list 2>/dev/null | sed -n '1,200p' || echo "N√£o consegui listar rotas."
                ;;

            4)
                echo "Limpando cache/config/rotas..."
                php artisan cache:clear >/dev/null 2>&1 && echo "cache:clear OK" || echo "cache:clear falhou"
                php artisan config:clear >/dev/null 2>&1 && echo "config:clear OK" || echo "config:clear falhou"
                php artisan route:clear >/dev/null 2>&1 && echo "route:clear OK" || echo "route:clear falhou"
                ;;

            5)
                # pega credenciais do .env
                DB_CONN=$(read_env "DB_CONNECTION")
                DB_HOST=$(read_env "DB_HOST")
                DB_PORT=$(read_env "DB_PORT")
                DB_DATABASE=$(read_env "DB_DATABASE")
                DB_USERNAME=$(read_env "DB_USERNAME")
                DB_PASSWORD=$(read_env "DB_PASSWORD")

                echo -e "\nDB_CONNECTION: ${DB_CONN:-(n√£o definido)}"
                echo "DB_DATABASE: ${DB_DATABASE:-(n√£o definido)}"
                echo "DB_HOST: ${DB_HOST:-(n√£o definido)}"
                echo "DB_PORT: ${DB_PORT:-(n√£o definido)}"
                echo

                if [ "$DB_CONN" = "mysql" ] || [ -z "$DB_CONN" ] && [ -n "$DB_DATABASE" ]; then
                    if command -v mysql &>/dev/null; then
                        echo "Tentando conectar com mysql client..."
                        # usa MYSQL_PWD para n√£o expor senha em argv
                        if [ -z "$DB_PORT" ]; then DB_PORT=3306; fi
                        MYSQL_PWD="$DB_PASSWORD" mysql -u "$DB_USERNAME" -h "${DB_HOST:-127.0.0.1}" -P "$DB_PORT" -D "$DB_DATABASE" -e "SHOW TABLES;" 2>/dev/null \
                            && echo "Listagem acima (mysql)" \
                            || echo "Falha ao listar tabelas via mysql. Checa se cliente mysql t√° ok e credenciais."
                    else
                        echo "Cliente mysql n√£o encontrado no PATH."
                    fi
                elif [ "$DB_CONN" = "sqlite" ] || [ -n "$DB_DATABASE" ] && [[ "$DB_DATABASE" == *.sqlite* || "$DB_DATABASE" == database/* ]]; then
                    DB_FILE="$DB_DATABASE"
                    if [ -f "$DB_FILE" ]; then
                        if command -v sqlite3 &>/dev/null; then
                            echo "Tabelas sqlite:"
                            sqlite3 "$DB_FILE" ".tables"
                        else
                            echo "sqlite3 n√£o encontrado no PATH."
                        fi
                    else
                        echo "Arquivo sqlite n√£o encontrado em $DB_FILE"
                    fi
                else
                    echo "Tipo de DB n√£o suportado automaticamente: ${DB_CONN:-desconhecido}. S√≥ tentei mysql/sqlite aqui."
                fi
                ;;

            6)
                echo "Filas e jobs:"
                php artisan queue:failed 2>/dev/null | sed -n '1,200p' || echo "Nenhum job failed listado ou comando falhou."
                ;;

            7)
                echo "Criando link storage (storage:link)..."
                php artisan storage:link >/dev/null 2>&1 && echo "storage:link OK" || echo "Falha ao criar storage link (checa permiss√µes)."
                ;;

            8)
                echo "Voltando..."
                devfetch
                ;;

            *)
                echo -e "\e[31m[ X ]\e[0m Op√ß√£o inv√°lida, bota um n√∫mero certo a√≠."
                ;;
        esac
    done
}

show_git() {
    if git rev-parse --is-inside-work-tree &>/dev/null; then
        # pega as infos do git
        url=$(git config --get remote.origin.url 2>/dev/null)
        clean=$(echo "$url" | sed -E 's#(git@|https?://)##; s#[:/]#/#g; s#\.git$##')
        owner=$(echo "$clean" | awk -F'/' '{print $(NF-1)}')
        repo=$(echo "$clean" | awk -F'/' '{print $NF}')
        branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "desconhecido")
        commits=$(git status --porcelain 2>/dev/null | wc -l)
        last_commit=$(git log -1 --pretty=format:'%s (%an)' 2>/dev/null || echo "nenhum commit")
        version=$(git describe --tags --abbrev=0 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "nenhuma vers√£o")

        # organiza infos em array
        infos=(
            "Git vers√£o: $(git --version 2>/dev/null | awk '{print $3}')"
            "URL: ${url:-n√£o configurado}"
            "Repo: ${repo:-desconhecido}"
            "Owner: ${owner:-desconhecido}"
            "Branch: ${branch:-desconhecido}"
            "Vers√£o: ${version:-desconhecido}"
            "Commits pendentes: ${commits}"
            "√öltimo commit: ${last_commit}"
        )

        # joga o ascii em linhas
        ascii_lines=()
        while IFS= read -r line; do
            ascii_lines+=("$line")
        done < <(printf "%b\n" "$ascii_git")

        # imprime lado a lado
        for i in "${!ascii_lines[@]}"; do
            left="${ascii_lines[$i]}"
            right="${infos[$i]}"
            printf "%-35s %s\n" "$left" "$right"
        done
    else
        echo
        echo -e "\e[31m[ X ]\e[0m N√£o est√° em um reposit√≥rio"  
    fi
}

show_docker() {
    echo -e "\nüì¶ \e[36mDocker\e[0m"

    # detectar docker ou podman
    if command -v docker &>/dev/null; then
        ENGINE="docker"
    elif command -v podman &>/dev/null; then
        ENGINE="podman"
    else
        echo -e "\e[31m[ X ]\e[0m Docker/Podman: n√£o encontrado"
        return
    fi

    # checar se o daemon responde
    if ! $ENGINE info &>/dev/null; then
        echo -e "‚ö†Ô∏è  $ENGINE instalado, mas o daemon n√£o est√° rodando"
        return
    fi

    # vers√£o
    echo -e "Vers√£o: $($ENGINE --version | head -n1)"

    # compose (plugin ou bin√°rio)
    if command -v docker-compose &>/dev/null; then
        echo -e "Compose: $(docker-compose --version | head -n1)"
    elif $ENGINE compose version &>/dev/null; then
        echo -e "Compose (plugin): $($ENGINE compose version | head -n1)"
    fi

    # contagens
    running_count=$($ENGINE ps -q | wc -l)
    total_count=$($ENGINE ps -a -q | wc -l)
    images_count=$($ENGINE images -q | wc -l)
    dangling_count=$($ENGINE images -f "dangling=true" -q | uniq | wc -l)
    echo -e "Containers: üü¢ $running_count ativos / ‚ö™ $total_count total"
    echo -e "Imagens: üì∏ $images_count (üßπ $dangling_count √≥rf√£s)"

    # containers rodando
    if [ "$running_count" -gt 0 ]; then
        echo -e "\nüß± Containers ativos:"
        $ENGINE ps --format " - \e[32m{{.Names}}\e[0m ({{.Status}}) [{{.Ports}}]" | sed -n '1,8p'
    fi

    # top CPU/MEM (snapshot)
    echo -e "\nüî• Uso de recursos:"
    $ENGINE stats --no-stream --format " - {{.Name}} ‚Üí CPU: {{.CPUPerc}} | MEM: {{.MemUsage}}" | sort -k2 -r | sed -n '1,5p'

    # uso de disco
    echo -e "\nüíæ Espa√ßo usado:"
    $ENGINE system df --format "   {{.Type}}: {{.TotalSize}} (Reclam√°vel: {{.Reclaimable}})" | sed -n '1,6p'

    # compose status (no diret√≥rio atual)
    if [ -f "docker-compose.yml" ] || [ -f "docker-compose.yaml" ] || [ -f "compose.yaml" ]; then
        echo -e "\nüß© docker-compose detectado:"
        if command -v docker-compose &>/dev/null; then
            docker-compose ps --services --filter "status=running" 2>/dev/null | sed 's/^/ - /'
        else
            $ENGINE compose ps --format "json" 2>/dev/null | jq -r '.[].Service' 2>/dev/null | sed 's/^/ - /'
        fi
    fi

    # mapa de portas
    echo -e "\nüåê Portas mapeadas:"
    $ENGINE ps --format " - {{.Names}} ‚Üí {{.Ports}}" | sed -n '1,10p'

    # alertas simples
    restarting=$($ENGINE ps --filter "status=restarting" -q | wc -l)
    if [ "$restarting" -gt 0 ]; then
        echo -e "\n‚ö†Ô∏è  Aviso: $restarting container(es) reiniciando!"
    fi
}


loop_fetch_git() {
    # salva o cursor no topo
    tput civis # esconde o cursor (fica mais clean)
    trap "tput cnorm; exit" INT TERM # volta o cursor quando sair

    while true; do
        tput cup 0 0   # manda o cursor pra linha 0, coluna 0
        printf '\033[0J'  # limpa da posi√ß√£o at√© o fim da tela

        echo -e "_____________________________DevFetch_____________________________"
        show_git

        sleep 10
    done
}

loop_fetch_laravel() {
    # salva o cursor no topo
    tput civis # esconde o cursor (fica mais clean)
    trap "tput cnorm; exit" INT TERM # volta o cursor quando sair

    while true; do
        tput cup 0 0   # manda o cursor pra linha 0, coluna 0
        printf '\033[0J'  # limpa da posi√ß√£o at√© o fim da tela

        echo -e "\e[31m_____________________________DevFetch_____________________________\e[0m"
        echo 
        show_laravel

        sleep 10
    done
}       

# ================================
# Main
# ================================
main() {
    case "$1" in
        update)
            update_devfetch
            ;;
        autoupdate-on)
            set_config "auto_update" "true"
            echo "üîÑ Atualiza√ß√£o autom√°tica ativada."
            ;;
        autoupdate-off)
            set_config "auto_update" "false"
            echo "‚è∏Ô∏è Atualiza√ß√£o autom√°tica desativada."
            ;;
        --dev)
            show_dev
            ;;
        --git)
            loop_fetch_git
            ;;
        --docker)
            show_docker
            ;;
        --laravel)
            loop_fetch_laravel
            ;;
        --loop_git)
            loop_fetch_git
            ;;

        --loop_laravel) 
            loop_fetch_laravel
            ;;

        --all)
            show_dev
            echo
            show_docker
            echo
            show_git
            ;;
        "" )
            menu
            ;;
        *)
            echo
            echo -e "\e[31m[ X ]\e[0m Uso incorreto!"
            echo "[ - ] Uso: $0 [--dev | --git | --docker | --laravel | --all | --loop | update | autoupdate-on | autoupdate-off]"
            exit 1
            ;;
    esac
}

main "$@"